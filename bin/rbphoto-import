#!/usr/bin/ruby
#
#
#

require 'getoptlong'
require 'fileutils'
require 'exif'

$RBPHOTO_VERSION = '0.1'

class Exif
  def datetime
    self.each_entry do |name, value|
      return value if name.match(/^Date and Time/)
    end
  end
end

class RbPhoto

  class Args < Hash
    def initialize
      parser = GetoptLong.new(
	['--datedir',	'-D',	GetoptLong::NO_ARGUMENT],
	['--move',	'-m',	GetoptLong::NO_ARGUMENT],
	['--without-rename',	'-N',	GetoptLong::NO_ARGUMENT],
	['--photographer',	'-p',	GetoptLong::REQUIRED_ARGUMENT],
	['--no-act',		'-n',	GetoptLong::NO_ARGUMENT],
	['--force',		'-f',	GetoptLong::NO_ARGUMENT],
	['--verbose',		'-v',	GetoptLong::NO_ARGUMENT],
	['--help',		'-h',	GetoptLong::NO_ARGUMENT],
	['--version', '-V',			GetoptLong::NO_ARGUMENT])
      begin
	parser.each do |name, arg|
    arg = true if (arg == "")
	  self[name.sub(/^--/, '').gsub(/-/, '_').downcase] = arg
	end
      rescue
	self['help'] = true
      end
    end
  end

  class Import

    def initialize
      @args = RbPhoto::Args.new
      @fileopts = {:force => @args['force'],
                   :verbose => @args['verbose'],
                   :noop => @args['no_act']}
      @postfix = '-' + ENV['USER']
      if ( @args['version'] )
	print self.version
	exit
      elsif ( @args['help'] || ARGV.size < 2 )
	print self.help
	exit
      end
      @dstdir = ARGV.pop
      @target = self.prepare_target(ARGV)
      @postfix = "-#{@args['photographer']}" if ( @args['photographer'] )
      self.copy
    end

    def prepare_target(args = ARGV)
      ret = []
      args.each do |arg|
	if (File.directory?(arg))
	  ret.concat(Dir.glob("#{arg}/*.{jpg,jpeg,JPG,JPEG}"))
	else
	  ret.push(arg)
	end
      end
      return ret
    end

    def copy
      @target.each do |file|
	if ( @args['without_rename'] )
	  target_file = file
	else
	  target_file = self.rename(file)
	end

	target_dir = File.dirname(target_file)
	if ( ! File.directory?(target_dir) )
	  FileUtils.makedirs(target_dir, @fileopts)
	end

	begin
	  if ( @args['move'] )
	    FileUtils.mv(file, target_file, @fileopts)
	  else
	    FileUtils.cp(file, target_file, @fileopts)
	  end
	  FileUtils.chmod(0444, target_file, @fileopts)
	rescue
	  
	end
      end
    end

    def rename(filename)
      datedir = ''
      time = Time.at(0)
      begin
        exif = Exif.new(filename)
        time = Time.local(*exif.datetime.split(/[:\s]/))
      rescue
        STDERR.print "Cannot read exif data correctly: #{filename}\n"
        return @dstdir + "/#{File.basename(filename, '.*')}#{@postfix}.jpg"
      end
      datedir = '/' + time.strftime('%Y-%m-%d') if ( @args['datedir'] )
      return @dstdir + datedir + "/#{time.strftime('%Y%m%d-%H%M%S')}#{@postfix}.jpg"
    end
 
    def help
      return <<_EOT
Usage: #{$0} [options] src_(dir|file)[s]... target_dir
Copy photo image from src to target.  it renames photo file name
not to duplicate by its exif data.

Options:
  -D, --datedir              copy/move photos with datedir
  -f, --force                force to overwrite when move
  -m, --move                 move photos instead of copy
  -N, --without-rename       do not rename photo files
  -p, --photographer=id      set photographer id (default: $USER)
  -n, --no-act               do not copy/move only test
  -h, --help                 show this help
  -v, --verbose              make verbose output
  -V, --version              show software version
_EOT
    end

    def version
      return <<_EOT
rbphoto-import (rbphoto) #{$RBPHOTO_VERSION}

Copyright (C) Taku YASUI <tach@debian.or.jp>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
_EOT
    end
  end

end

RbPhoto::Import.new

# vim: set ts=2 sw=2 expandtab:
